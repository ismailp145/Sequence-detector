#### USING ONLY python's STANDARD LIBRARY COMPLETE THE FOLLOWING CODE

#### There are 9 methods worth 75 points that you must write to gain 
#### full credit for the sequence_properties.py module. See below.

from email.headerregistry import AddressHeader
import math
# from msilib import sequence
from typing import Counter

# @param seq a list of numerical values 
# Precondition: the length of seq > 1 
# @return a list of numerical values with precision 5, 
# where the element at index k is equal to the 
# difference between the elements at indices k + 1 and k of seq. 
def getDiffs(seq):
    lyst = []
    counter = 0
    while counter+1 != len(seq):
        value = round(seq[counter+1] - seq[counter], 5)
        lyst.append(value)
        counter += 1
    return lyst
   

	
### YOU MUST USE THE getDiffs FUNCTION WHEN IMPLEMENTING THE ###
### isLinear FUNCTION ###
 
# @param seq a list of integer values 
# Precondition: seq.length > 1 
# @return true if seq is linear: that is the differences between all 
# consecutive pairs of elements in seq are identical; false otherwise.
def isLinear(seq):
    lyst = getDiffs(seq)
    diff = lyst[0]
    for element in lyst:
        if element != diff:
            return False
    
    return True
	


### YOU MUST USE THE getDiffs AND isLinear FUNCTIONS WHEN ###
### IMPLEMENTING THE isQuadratic FUNCTION
 
#@param seq a list of integer values 
#Precondition: seq.length > 2 
#@return true if seq is quadratic: that is the sequence is not linear, and
#the differences between all consecutive pairs of elements in seq form a 
#linear sequence; false otherwise. 
def isQuadratic(seq):

    if isLinear(seq) == False and isLinear(getDiffs(seq)):
        return True
    else:
        return False
	
	
# @param seq a list of numerical values 
# Precondition: the length of seq > 1 
# @return a list of numerical values with precision 5, 
# where the element at index k is equal to the 
# quotients of the elements at indices k + 1 and k of seq  
def getRatios(seq):
    lyst = []
    counter = 0
    while counter + 1 != len(seq):
        value = seq[counter+1] / seq[counter]
        value = round(value, 5)
        lyst.append(value)
        counter +=1
    return lyst
	
### YOU MUST USE THE getRatios FUNCTIONS WHEN ###
### IMPLEMENTING THE isGeometric FUNCTION

# @param seq a list of integer values 
# Precondition: seq.length > 2 
# @return true if seq is geometric: that is the ratios between all 
# consecutive pairs of elements in seq are identical to within
# five decimal places;false otherwise.
def isGeometric(seq):
    lyst = getRatios(seq)
    ratio = lyst[0]
    for element in lyst:
        if element != ratio:
            return False	

    return True
	
# @param mx_plus_b a string containing a linear expression of the form 
# mx + b  
# Precondition: mx_plus_b must be a valid linear expression in the form
# mx + b 
# @return a list containing the slope m and vertical intercept b
# both as float values. The slope should be stored in the list first
# followed by the vertical intercept
def getLinearParameters(mx_plus_b):
    lyst = []
    x_index = mx_plus_b.index("x")
    slope = float(mx_plus_b[:x_index])
    lyst.append(slope)
    
    if "+" in mx_plus_b:
        plus_index = mx_plus_b.index("+")
        v_inter = float(mx_plus_b[plus_index+1:])
        lyst.append(v_inter)



    return lyst
	
### YOU MUST USE THE getLinearParameters FUNCTION WHEN ###
### IMPLEMENTING THE linearTransformation FUNCTION	
# @params seq a list of numerical values, mx_plus_b a string containing 
# a linear expression of the form mx + b  
# Preconditions: the length of seq > 1, mx_plus_b must be a valid 
# linear expression in the form mx + b 
# @return a list containing values generated by multiplying each element
# of seq by the slope m followed by adding the vertical intercept b.
# For example, if seq = [2, 4, 8, 16], and mx_plus_b = "3x-4", then the 
# return list would be [2, 8, 20, 44]
def linearTransformation(seq, mx_plus_b):
    lyst = getLinearParameters(mx_plus_b)
    slope = lyst[0]
    if len(lyst) == 2:
        v_inter = lyst[1]
        new = [int(element*slope + v_inter) for element in seq]
    else:
        new = [int(element*slope) for element in seq]

    return new
	
### YOU MUST USE THE getLinearParameters FUNCTION WHEN ###
### IMPLEMENTING THE linearSequence FUNCTION
# @params num_terms the number of terms to generate, mx_plus_b a 
# string containing a linear expression of the form mx + b  
# Preconditions: num_terms > 1, mx_plus_b must be a valid 
# linear expression in the form mx + b 
# @return a list containing the terms of the linear sequence
def linearSequence(num_terms, mx_plus_b):
    new = []
    lyst = getLinearParameters(mx_plus_b)
    slope = lyst[0]
    v_inter = lyst[1]
    counter = 0
    for element in range(1,num_terms+1):
        new.append(element * slope + v_inter)
    return new
	
	
# @param seq a list of numerical values that form a linear sequence
# Precondition: seq.length > 1 
# @return a string in the form mx + b that defines the linear sequence
# For example, if seq = [3, 8, 13, 18], then the function would
# return "5x-2"
def getLinearEquation(seq):
    first = seq[0]
    second = seq[1]
    diff = second - first
    intercept = first - diff

    return "{}x{}".format(diff, intercept)
